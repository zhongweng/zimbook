Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-03-01T13:44:11+08:00

====== IO ======
Created 星期三 01 三月 2017

在理想的情况下，系统崩溃、断电、磁盘访问失败这些情况是不会出现的，开发者编写程序时也不用为这些情况担忧。不幸的是，这些情况比我们想像的还经常出现。本文描述了数据是怎样一步步被写入磁盘上的，尤其是其中被缓冲的几个步骤。本文也提供了数据被正确写盘的最佳实践，以确保意外发生的时候，数据不会丢失。

====== I/O缓存 ======

在数据最终存入稳定存储器前，可能会经过多个层，如下图所示：
{{./pasted_image.png}}


	数据最初存在于**应用程序的内存或缓存**中的一个或多个块中。
	这些缓存中的数据可能被提交给一个具有自己**缓存的库**。
	抛开应用程序缓存与库缓存，这些数据都存在于**应用程序地址空间**中。
	数据经过的下一层是内核，**内核**有一个叫做**页缓存**的回写缓存。脏页会存放在页缓存中一段时间，这段时间的长短取决于系统的负载与I/O模式。
	最后，当脏数据离开内核的页缓存时，会被写入**存储设备**（如磁盘）。存储设备可能会进一步将数据缓存在**临时的回写缓存**中。如果这时发生了断电的情况，数据可能会丢失。
	最后一层是**稳定存储**。当数据到达这层时，就可以认为数据安全存入稳定存储器了。
	
====== I/O APIs ======

**I/O分为3个部分：系统I/O,流I/O,内存映射I/O**

===== 系统I/O =====
	可以被定义为任何通过内核系统调用将数据定入内核地址空间中的存储层的操作。下面的程序（不全面的，重点在写操作）是系统调用的一部分：

		**Operation	Function(s)**
		**Open		open(), creat()**
		**Write		write(), aio_write(),pwrite(), pwritev()**
		**Sync		fsync(), sync()**
		**Close		close()**

===== 流I/O =====
	用C语言库的流接口进行初始化的I/O。使用这些函数进行写的操作并不一定产生系统调用，即**在一次这样的函数调用后，数据仍然存在于应用程序地址空间中的缓存中**。下面的库程序（不全面）是流接口的一部分：

		**Operation	Function(s)**
		**Open		fopen(), fdopen(),freopen()**
		**Write		fwrite(), fputc(),fputs(), putc(), putchar(),puts()**
		**Sync		fflush(), followed by   fsync() or	sync()**
		**Close		fclose()**

===== 内存映射I/O =====
	文件仍然使用相同的接口打开与关闭，但对文件数据的访问，是通过**将数据映射入进程的地址空间**进行的，然后像读写其它应用程序缓存一样进行读写操作：

		**Operation	Function(s)**
		**Open		open(), creat()**
		**Map		mmap(),memcpy(), memmove()**
		**Write		write(), or any other routine that writes to application memory**
		**Sync		msync()**
		**Unmap		munmap()**
		**Close		close()**


	打开一个文件时，有两个标志可以指定，用以改变缓存行为：**O_SYNC**（ 或相关的O_DSYNC）与**O_DIRECT**。**对以O_DIRECT方式打开的文件的I/O操作，会绕开内核的页缓存，直接写入存储器**。回想下，**存储系统仍然可能将数据存入一个写回缓存中**，**因此，对于以O_DIRECT打开的文件，需要调用fsync()确保将数据存入稳定存储器中**。O_DIRECT标志仅与系统I/O API相关。


===== 什么时候执行fsync操作 =====
	可以根据一些简单的规则，决定是否调用fsync()。首先，也是最重要的，你必须明白：有没有必要将数据立即存入稳定存储中？如果是不重要的数据，那么不必立即调用fsync(). 如果是可再生的数据，也没有太大的必要立即调用fsync()。另一方面，如果你要存储一个事务的结果，或更新用户的配置文件，你很希望得到正确的结果。在这些情况下，应该立即调用fsync()。

	更微妙之处在于新创建的文件，或重写已经存在的文件。**新创建的文件不仅仅需要fsync()，其父目录也需要fsync()**（因为这是文件系统定位你的文件之处）。这类同步行为依赖于文件系统（和挂载选项）的实现。你可以对专门为每一个文件系统与挂载选项进行特殊编码，或者显示调用fsync(),以确保代码的可移植性。

	类似的，当你**覆盖一个文件时**，如果遭遇系统失败（例如断电，ENOSPC或I/O错误），很可能会造成已有数据的丢失。为避免这种情况，通常的做法（也是建议的做法）是将要更新的数据写入一个临时文件，确保它在稳定存储上的安全，然后将临时文件重命名为原始的文件名（以代替原始的内容）。这确保了对文件更新操作的原子性，以使其它读取用户得到数据一个副本。以下是这种更新类型的操作步骤：

		**create a new temp file (on the same file system!)**
		**write data to the temp file**
		**fsync() the temp file**
		**rename the temp file to the appropriate name**
		**fsync() the containing directory**

===== 错误检查 =====
	进行由库或内核缓存的写I/O时，由于数据可能仅仅被写入页缓存，例如在执行write()或fflush()时，可能会产生不被报告的错误。相反，在调用fsync(),msync()或close()时，由写操作产生的错误会被报告。因此，检查这些调用的返回值是很重要的。


====== 清除和设置文件缓冲区 ======

===== (1).清除文件缓冲区函数： =====

	**int fflush(FILE *stream); **
	
	**int flushall();**

	 fflush()函数将清除由stream指向的文件缓冲区里的内容，常用于写完一些数据后，立即用该函数清除缓冲区，以免误操作时，破坏原来的数据。 flushall()将清除所有打开文件所对应的文件缓冲区。


===== (2).设置文件缓冲区函数 =====

	**void setbuf(FILE *stream,char *buf); **
	
	**void setvbuf(FILE *stream,char *buf,int type,unsigned size);** 

	这两个函数将使得打开文件后，用户可建立自己的文件缓冲区，而不使用fopen()函数打开文件设定的默认缓冲区。 对于setbuf()函数，buf指出的缓冲区长度由头文件stdio.h中定义的宏BUFSIZE的值决定，缺省值为512字节。当选定buf为空时，setbuf函数将使的文件I/O不带缓冲。而对setvbuf函数，则由malloc函数来分配缓冲区。参数size指明了缓冲区的长度(必须大于0),而参数type则表示了缓冲的类型，其值可以取如下值： type 值 含义 _IOFBF 文件全部缓冲，即缓冲区装满后，才能对文件读写 _IOLBF 文件行缓冲，即缓冲区接收到一个换行符时，才能对文件读写 _IONBF 文件不缓冲，此时忽略buf,size的值，直接读写文件，不再经过文件缓冲区缓冲。


====== 文件的随机读写函数 ======

	前面介绍的文件的字符/字符串读写，均是进行文件的顺序读写，即总是从文件的开头开始进行读写。这显然不能满足我们的要求，C语言提供了移动文件指针和随机读写的函数，它们是：


===== (1).移动文件指针函数： =====

		 **long ftell(FILE *stream);**
		
		** int rewind(FILE *stream);**
		
		** fseek(FILE *stream,long offset,int origin);**

	 函数ftell()用来得到文件指针离文件开头的偏移量。当返回值是-1时表示出错。 rewind()函数用于文件指针移到文件的开头，当移动成功时，返回0，否则返回一个非0值。 fseek()函数用于把文件指针以origin为起点移动offset个字节，其中origin指出的位置可有以下几种：

	 origin 数值 代表的具体位置 

		**SEEK_SET 0 文件开头**
		
		** SEEK_CUR 1 文件指针当前位置**
		
		** SEEK_END 2 文件尾** 
		
	例如： fseek(fp,10L,0); 把文件指针从文件开头移到第10字节处，由于offset参数要求是长整型数，故其数后带L。fseek(fp,-15L,2); 把文件指针从文件尾向前移动15字节。

===== (2).文件随机读写函数 =====

	 **int fread(void *ptr,int size,int nitems,FILE *stream);**
	
	** int fwrite(void *ptr,int size,int nitems,FILE *stream);**

	fread()函数从流指针指定的文件中读取nitems个数据项，每个数据项的长度为size个字节，读取的nitems数据项存入由ptr指针指向的内存缓冲区中，在执行fread()函数时，文件指针随着读取的字节数而向后移动，最后移动结束的位置等于实际读出的字节数。该函数执行结束后，将返回实际读出的数据项数，这个数据项数不一定等于设置的nitems，因为若文件中没有足够的数据项，或读中间出错，都会导致返回的数据项数少于设置的nitems。当返回数不等于nitems时，可以用feof()或ferror()函数进行检查。
	 fwrite()函数从ptr指向的缓冲区中取出长度为size字节的nitems个数据项，写入到流指针stream指向的文件中，执行该操作后，文件指针将向后移动，移动的字节数等于写入文件的字节数目。该函数操作完成后，也将返回写入的数据项数。


