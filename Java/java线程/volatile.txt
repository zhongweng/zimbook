Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-02-28T08:44:42+08:00

====== volatile ======
Created 星期一 27 二月 2017

===== volatile变量特性 =====

	**可见性**:对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
	**原子性**:对任意单个volatile变量的读/写具有原子性，**但类似于volatile++这种复合操作不具有原子性**。
	JVM底层采用“**内存屏障**”来实现volatile语义

Volatile变量修饰符如果使用恰当的话，它比synchronized的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。

有volatile变量修饰的共享变量进行**写操作**的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。

	**将当前处理器缓存行的数据会写回到系统内存。**
	**这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。**


===== 应用场景 =====
	volatile经常用于两个两个场景：**状态标记两、double check**
	

===== Volatile的使用优化 =====

著名的Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue，他在使用Volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。
	
	为什么追加64字节能够提高并发编程的效率呢？ 因为对于英特尔酷睿i7，酷睿， Atom和NetBurst， Core Solo和Pentium M处理器的L1，L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头尾节点，当一个处理器试图修改头接点时会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作是需要不停修改头接点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头接点和尾节点加载到同一个缓存行，使得头尾节点在修改时不会互相锁定。

	那么是不是在使用Volatile变量时都应该追加到64字节呢？不是的。在两种场景下不应该使用这种方式。第一：缓存行非64字节宽的处理器，如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。第二：共享变量不会被频繁的写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，共享变量如果不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。


===== 实现原理 =====

==== 内存模型相关概念 ====

=== 操作系统语义 ===
计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。

有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。举一个简单的例子：
**i++**
当线程运行这段代码时，首先会从主存中读取i( i = 1)，然后复制一份到CPU高速缓存中，然后CPU执行 + 1 （2）的操作，然后将数据（2）写入到告诉缓存中，最后刷新到主存中。其实这样做在单线程中是没有问题的，有问题的是在多线程中。如下

两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。

解决缓存一致性方案有两种：

	1. **通过在总线加LOCK#锁的方式**
	2. **通过缓存一致性协议**

	第一种方案，是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。
	
	第二种方案，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。
	{{./pasted_image.png}}
	
	

=== Java内存模型 ===
	上面从操作系统层次阐述了如何保证数据一致性，下面我们来看一下Java内存模型，稍微研究一下Java内存模型为我们提供了哪些保证以及在Java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。
	
	在并发编程中我们一般都会遇到这三个基本概念：**原子性、可见性、有序性**。我们稍微看下volatile．
	
	**原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**
	
		原子性就像数据库里面的事务一样，他们是一个团队，同生共死。其实理解原子性非常简单，我们看下面一个简单的例子即可：
		i = 0;            ---1
		j = i ;            ---2
		i++;            ---3
		i = j + 1;    ---4
		
		上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。
		
		1—**在Java中，对基本数据类型的变量和赋值操作都是原子性操作；** 
		2—包含了两个操作：读取i，将i值赋值给j 	非原子
		3—包含了三个操作：读取i值、i + 1 、将+1结果赋值给i； 	非原子
		4—同三一样		非原子
		
		在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的**（注：在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double）。要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。**
		
		**volatile是无法保证复合操作的原子性**
	
	**可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。**
	
		在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。
		**Java提供了volatile来保证可见性。**
		当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。 
		当然，**synchronize和锁都可以保证可见性。**
	
	**有序性：即程序执行的顺序按照代码的先后顺序执行。**
		**在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。**
		
		Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。这里LZ就不再阐述了。


==== 剖析volatile原理 ====

	volatile保证:
	**可见性**
	**读/写原子性**
	**禁止指令重排序**
	
	在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序：
	
	1. **编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；**
	2. **处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；**
 
	指令重排序对单线程没有什么影响，他不会影响程序的运行结果，但是会影响多线程的正确性。既然指令重排序会影响到多线程执行的正确性，那么我们就需要禁止重排序。那么JVM是如何禁止重排序的呢？这个问题稍后回答，我们先看另一个原则happens-before，**happen-before原则**保证了程序的“有序性”，它规定如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。其定义如下：
	
	1. 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则**无法保证编译重排和指令重排**）。
	2. **监视器上的解锁**操作 happen-before 其后续的加锁操作。（Synchronized 规则）
	3. 对**volatile变量的写**操作 happen-before 后续的读操作。（volatile 规则）
	4. 线程的**start()** 方法 happen-before 该线程所有的后续操作。（线程启动规则）
	5. 线程所有的操作 happen-before 其他线程在该线程上调用 **join** 返回成功后的操作。
	6. 如果 a happen-before b，b happen-before c，则a happen-before c（**传递性**）。

	{{./pasted_image001.png}}
	
	观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。**volatile的底层就是通过内存屏障来实现的。**


=== 与happens-before ===
{{{code: lang="java" linenumbers="True"
public class VolatileTest {

    int i = 0;
    volatile boolean flag = false;

    //Thread A
    public void write(){
        i = 2;              //1
        flag = true;        //2
    }

    //Thread B
    public void read(){
        if(flag){                                   //3
            System.out.println("---i = " + i);      //4
        }
    }
}
}}}
	
	
	依据happens-before原则，就上面程序得到如下关系：
	
	依据happens-before程序顺序原则：1 happens-before 2、3 happens-before 4；
	根据happens-before的volatile原则：2 happens-before 3；
	根据happens-before的传递性：1 happens-before 4
	操作1、操作4存在happens-before关系，那么1一定是对4可见的。可能有同学就会问，操作1、操作2可能会发生重排序啊，会吗？如果看过LZ的博客就会明白，volatile除了保证可见性外，还有就是禁止重排序。所以A线程在写volatile变量之前所有可见的共享变量，在线程B读同一个volatile变量后，将立即变得对线程B可见。
	
=== 内存语义及其实现 ===
	在JMM中，**线程之间的通信采用共享内存**来实现的。volatile的内存语义是：
	**当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新到主内存中。**
	**当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量**
	为了实现volatile的内存语义JMM会限制重排序。其重排序规则如下：
	
	翻译如下：
	
	如果**第一个操作为volatile读**，则不管第二个操作是啥，都不能重排序。这个操作确保volatile读之后的操作不会被编译器重排序到volatile读之前；
	当**第二个操作为volatile写**，则不管第一个操作是啥，都不能重排序。这个操作确保volatile写之前的操作不会被编译器重排序到volatile写之后；
	当**第一个操作volatile写，第二操作为volatile读时，不能重排序**。
	**volatile的底层实现是通过插入内存屏障**，但是对于编译器来说，发现一个最优布置来最小化插入内存屏障的总数几乎是不可能的，所以，JMM采用了保守策略。如下：
	
	在每一个volatile写操作前面插入一个StoreStore屏障
	在每一个volatile写操作后面插入一个StoreLoad屏障
	在每一个volatile读操作前面插入一个LoadLoad屏障
	在每一个volatile读操作后面插入一个LoadStore屏障
	
	**StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。**
	
	**StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。**
	
	**LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。**
	
	**LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。**
	{{./pasted_image003.png}}


==== 总结 ====
	volatile相对于synchronized稍微轻量些，在某些场合它可以替代synchronized，但是又不能完全取代synchronized，只有在某些场合才能够使用volatile。使用它必须满足如下两个条件：
	
	1. **对变量的写操作不依赖当前值；**
	2. **该变量没有包含在具有其他变量的不变式中。**











































