Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-03-06T15:24:56+08:00

====== interrupt ======
Created 星期一 06 三月 2017

===== interrupt()说明 =====
	Interrupts this thread.
	Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.
	
	If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.
	
	If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.
	
	If this thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.
	
	If none of the previous conditions hold then this thread's interrupt status will be set.
	
	Interrupting a thread that is not alive need not have any effect.
	
	翻译：
	interrupt()的作用是中断本线程。
	本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。
	如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。**若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。**
	如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。
	如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。
	中断一个“已终止的线程”不会产生任何操作。
	
===== 终止线程的方式 =====
	**Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！**
	下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。

==== 终止处于“阻塞状态”的线程 ====
	通常，我们通过“中断”方式终止处于“阻塞状态”的线程。
	当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下
	
	**@Override**
	**public void run() {**
	**    try {**
	**        while (true) {**
	**            // 执行任务...**
	**        }**
	**    } catch (InterruptedException ie) {  **
	**        // 由于产生InterruptedException异常，退出while(true)循环，线程终止！**
	**    }**
	}
	
	
	说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！
	注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：
	
	**@Override**
	**public void run() {**
	**    while (true) {**
	**        try {**
	**            // 执行任务...**
	**        } catch (InterruptedException ie) {  **
	**            // InterruptedException在while(true)循环体内。**
	**            // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出**
	**            break;**
	**        }**
	**    }**
	**}**
	
==== 终止处于“运行状态”的线程 ====
	通常，我们通过**“标记”方式**终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。
	**(01) 通过“中断标记”终止线程。**
	形式如下：
	public void run() {
		while (!isInterrupted()) {
			// 执行任务...
		}
	}
	
	说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。
	**注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。**
	
	**(02) 通过“额外添加标记”。**
	形式如下：
	private **volatile** boolean flag= true;
	protected void stopTask() {
		flag = false;
	}
	
	@Override
	public void run() {
		while (flag) {
			// 执行任务...
		}
	}
	
	说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。
	注意：**将flag定义为volatile类型，是为了保证flag的可见性**。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。

==== “阻塞状态”和“运行状态”的终止方式 ====
	比较通用的终止线程的形式如下：
	@Override
	public void run() {
		try {
			// 1. isInterrupted()保证，只要中断标记为true就终止线程。
			while (!isInterrupted()) {
				// 执行任务...
			}
		} catch (InterruptedException ie) {  
			// 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。
		}
	}
	
==== 应用场景 ====
	通常，中断的使用场景有以下几个：
	
	* **点击某个桌面应用中的取消按钮时；**
	* **某个操作超过了一定的执行时间限制需要中止时；**
	* **多个线程做相同的事情，只要一个线程成功其它线程都可以取消时；**
	* **一组线程中的一个或多个出现错误导致整组都无法继续时；**
	* **当一个应用或服务需要停止时。**


